# CS310
Over the past several weeks I have worked on developing software for Grand Strand Systems. The software included a contact and contact service build that was focused on the ability to add, delete and modify a contact based off their unique contactID. It also included a task and task service feature that allowed the user to add, delete and modify a task based off the taskID. Finally, the software included an appointment feature that would allow the user to create an appointment for a given date. All these features had specific requirements requested by the client, such as the strings can’t be null, they must be of certain lengths and for ID’s they must be unique. All the programming was done without any user interface. To ensure that both the program was functioning appropriately, and the client’s needs had been met, I had to implement various testing methods. 
In milestones three, four, and five I focused on Junit 5 testing with assertions. Assertions work in three steps, the first one being the identification of the expected value. The second step in the assertion process is receiving the real outcome. Finally, we compare the two values using logic comparators. The logic comparators that I used in my milestones are the assertTrue, assertFalse, assertEquals and the assertThrows comparators. 
	The process was the same throughout the project. For example, in the contactServiceTest.java file I implemented the assertions.assertThrows method for testing. The first argument that we use is the IllegalArgumentException.class. We then input our new contact, with some error in the contact for the test to identify. In this milestone, the throws were for string lengths that didn’t fit our client requirements. In other milestones, such as the appointment services, we were verifying that the date was in the future. In this milestone we also used the assertTrue method. We used this to verify that the add, update and delete functions worked properly. The assertTrue works by using an equal’s operator. We call our vector.getSomething().equals(“whatever it is we want to verify”) to verify that the add, update and delete function was implemented correctly and the current value matches the expected value. We can see that its technically sound if we look at ContactServiceTest.java lines 20 through 32. In this section we can see we are using our Junit testing to prove the contact was added correctly. It’s not enough to just establish tests and run them though. We must also ensure we are looking at the coverage percentage. The coverage tells us how much of the code was tested with our tests. In every aspect of this project, we had a coverage rate of greater than 80%. This means that over 80% of the code is being ran when the testing is done. If we have a lower percentage of coverage, we will want to evaluate the depth of our tests and see if we have any unnecessary code.  
	There are many ways to test our software to ensure that its fully functional. Although I focused on assertions for my Junit testing, we could have also used a different technique such as Hamcrest. Hamcrest works similarly to the assertions method that I chose to use. With Hamcrest testing, instead of assertTrue or assertFalse, we could use assertThat. This works similarly in that we are asking the test to verify that A is equal to B. All the different testing techniques that I have mentioned have their own practical uses and implications. The Junit testing worked well for this project because we were given specific program requirements. Hamcrest would have also worked in this situation but doesn’t offer the breadth that we needed. 
	Throughout this project I had to take a unique approach. This approach was mostly due to me writing both the code and creating the tests for it. I had to be cautious that I wasn’t being biased when writing the Junit tests. Since I knew what I was testing for and what I had already programmed, it would have been easy for me to “make it work” so that I would have a finished running project. To help me remove this bias and remain cautious, I tried to think of the project as an art piece. The way that all the code comes together within a project can be a beautiful process. I didn’t want to tarnish that beauty by not putting it through rigorous testing methods. Whenever I would get stuck or overwhelmed within the code, I would simply step away. This time away allowed me to appreciate the complexity and feel rewarded when things worked out. One specific example of this complexity is the date function within the appointment services file. Finding a solution for the client’s requirement took me a lot of time. In this case it would have been easy for me to write a test that worked with incorrect code or to have written a work around in the program. However, cutting corners doesn’t make me better at my job and there are plenty of examples out there where cutting corners not only costs money, but it can cost lives. Writing test cases for a program can be a daunting and exhausting task and sometimes we spend hours working on something for it to not work at all. This project taught me the importance of doing my due diligence as well as the importance of knowing when to take a break. 
